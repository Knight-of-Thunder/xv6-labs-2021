# 调度的流程
trap调用yield->sched->switch
switch通过切换上下文切换到scheduler
- 原进程在内核态下的寄存器已经被保存，换成调度线程scheduler的寄存器
- ra被换成调度线程中switch的返回地址，因为调度线程的switch保存了调度线程在执行switch时候的返回地址
之后在上一步中被替换给原进程使用。
- 调度线程选择一个进程执行，具体的方式就是通过上一步说的switch，把被选择的进程上下文放入cpu上的寄存器，
此时执行完switch后的返回地址是被选择进程在调用sched->switch时的返回地址。

# 关于调度过程中的锁
## 这就是为什么 p->lock 可能会在一个线程里获取，在另一个线程里释放

示例 1：yield() 里获取 p->lock，但在 scheduler() 里释放
- yield() 开始修改 p->state，把 RUNNING → RUNNABLE，这时候 c->proc 还是旧的，不满足不变量，必须持有 p->lock。
- 直到 scheduler() 运行，彻底完成切换，c->proc 清空，不变量恢复，才可以释放 p->lock。

示例 2：scheduler() 里获取 p->lock，但在 yield() 里释放
- scheduler() 让 RUNNABLE → RUNNING，必须持有 p->lock，直到 swtch() 完全切换成功，才可以释放 p->lock。

# 关于调度过程中的中断
- 首先，进入trap的时候是已经关闭中断的