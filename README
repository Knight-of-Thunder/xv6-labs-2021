# 睡眠锁
睡眠锁里面包了个自旋锁，这个自旋锁用来保护睡眠锁的状态，主要是locked字段

# cache buffer lab
总结一下这个实验遇到的坑：
核心难点在于bget函数，我最开始的代码，可能会导致一些问题情况：
1. 在遍历多个桶时，锁的获取和释放顺序不一致，可能形成循环等待（例如线程 A 持有桶1锁后请求桶2锁，线程 B 持有桶2锁后请求桶1锁）：解决的方式是按索引顺序获取锁（小号桶优先）
2. 竞态条件未处理：在释放锁后重新获取锁的过程中，未重新检查目标桶是否已被其他线程缓存相同的块，导致重复分配缓冲区。
（发现buffer uncached的时候，需要遍历所有桶以获取lru桶，之后需要重新检查目标中是否已有该块）
3. 锁能不嵌套调用尽量不嵌套调用，简单一点比较好，不然很可能出现该release的没有release，该获取的没获取；能尽早释放就尽早释放比较好，如果中间的不变量可能发生变化，那就再获取锁检查一遍就好（如2）