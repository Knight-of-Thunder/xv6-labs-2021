# 调度的流程
trap调用yield->sched->switch
switch通过切换上下文切换到scheduler
- 原进程在内核态下的寄存器已经被保存，换成调度线程scheduler的寄存器
- ra被换成调度线程中switch的返回地址，因为调度线程的switch保存了调度线程在执行switch时候的返回地址
之后在上一步中被替换给原进程使用。
- 调度线程选择一个进程执行，具体的方式就是通过上一步说的switch，把被选择的进程上下文放入cpu上的寄存器，
此时执行完switch后的返回地址是被选择进程在调用sched->switch时的返回地址。

# 关于调度过程中的锁
## 这就是为什么 p->lock 可能会在一个线程里获取，在另一个线程里释放

示例 1：yield() 里获取 p->lock，但在 scheduler() 里释放
- yield() 开始修改 p->state，把 RUNNING → RUNNABLE，这时候 c->proc 还是旧的，不满足不变量，必须持有 p->lock。
- 直到 scheduler() 运行，彻底完成切换，c->proc 清空，不变量恢复，才可以释放 p->lock。

示例 2：scheduler() 里获取 p->lock，但在 yield() 里释放
- scheduler() 让 RUNNABLE → RUNNING，必须持有 p->lock，直到 swtch() 完全切换成功，才可以释放 p->lock。

## sleep wakeup为什么有时候需要循环检查条件
- 防止虚假唤醒，所以唤醒之后，在持有锁的条件下再检查一遍

# callee saved register vs caller saved register
- 上下文切换的时候，只需要保存被调用者保存寄存器，因为调用者保存寄存器的值被保存在程序的堆栈中了
而被调用者保存寄存器的值会被调用的函数修改（一般的函数会在ret前复原这些值），但是线程切换则有所不同
我们的线程切换函数（switch汇编函数）只是重新加载切换到线程的寄存器值。
-- 这是因为线程和线程的切换不是通过函数返回的形式，而是切换寄存器值：本来的被调用函数不再恢复寄存器的值了，
被调用函数只是一个单纯的switch汇编（切换寄存器值）。
-- 如果不在switch中保存这些寄存器的值，那么被调用者保存寄存器的值是在调用switch函数的函数内被修改的寄存器值
--- 核心就一句话：原线程和切换到的线程之间没有一个调用关系，从切换到线程再一次返回原线程时，也不会帮他恢复callee 
saved regs。